---
title: File-Based Routing
description: Autodiscovered Vision sub-app routing (app/routes/**/index.ts)
---

import { Callout } from 'fumadocs-ui/components/callout';

# File-Based Routing

Vision Server automatically discovers and mounts route sub-apps from your filesystem. Place Vision sub-apps under `app/routes/**/index.ts` and they become HTTP endpoints. Dynamic segments use `[param]` folders.

<Callout type="success">
  Zero config: routes are autodiscovered from `app/routes/` by default. No manual import or registration required.
</Callout>

## When to Use

✅ **Best for:**
- Large APIs (50+ endpoints)
- Next.js users wanting familiar structure
- Teams that prefer file-system organization
- Collocating route logic with tests

❌ **Consider service builder if:**
- You need pub/sub + cron jobs in same file
- You prefer explicit service grouping
- You have a small API (less than 20 endpoints)

## Quick Start

### 1. Create routes directory

```
app/routes/
├── products/
│   ├── index.ts
│   └── [id]/
│       └── index.ts
└── analytics/
    └── dashboard/
        └── index.ts
```

### 2. Define a sub-app per folder

```ts
// app/routes/products/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app
  .service('products')
  .endpoint('GET', '/', { 
    input: z.object({}),
    output: z.object({
      products: z.array(z.object({ id: z.string(), name: z.string(), price: z.number() }))
    })
  }, async (_, c) => {
    const products = c.span('db.select', { 'db.table': 'products' }, () => [
      { id: '1', name: 'Laptop', price: 999 },
    ])
    return { products }
  })

export default app
```

### 3. Start your server

```ts
// src/index.ts
import { Vision } from '@getvision/server'

const app = new Vision({
  service: { name: 'My API' },
  // optional
  routes: { autodiscover: true, dirs: ['app/routes'] }
})

app.start(3000)
```

**Done!** Vision autoloads sub-apps from `app/routes/**/index.ts` and shows them in the Dashboard.

## File Structure

### Conventions

#### index.ts per folder

- Place an `index.ts` in each folder under `app/routes/` that exports a default Vision app.
- Folder path maps to URL base. The sub-app registers endpoints relative to that base using `'/'`.

```
app/routes/products/index.ts       → mounts at /products
app/routes/analytics/dashboard/index.ts → mounts at /analytics/dashboard
```

#### Dynamic Segments

Use `[param]` folders for dynamic routes:

```
app/routes/products/[id]/index.ts                 → /products/:id
app/routes/users/[userId]/posts/[postId]/index.ts → /users/:userId/posts/:postId
```

### Example Structure

```
app/routes/
├── products/
│   ├── index.ts                 → GET /products
│   ├── [id]/
│   │   └── index.ts             → GET /products/:id
│   └── create/
│       └── index.ts             → POST /products/create
├── users/
│   └── [id]/
│       └── orders/
│           └── index.ts         → GET /users/:id/orders
└── analytics/
    ├── dashboard/
    │   └── index.ts             → GET /analytics/dashboard
    └── track/
        └── index.ts             → POST /analytics/track
```

## Route Files

### Exports

Each route folder contains an `index.ts` that exports a Vision sub-app with one or more endpoints:

```ts
// app/routes/products/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('products')
  .use(authMiddleware) // optional service-level middleware
  .endpoint('GET', '/', { input: z.object({}), output: z.object({ products: z.array(z.object({ id: z.string() })) }) }, async (_, c) => {
    return { products: [] }
  })
  .endpoint('POST', '/', { input: z.object({ name: z.string(), price: z.number() }), output: z.object({ id: z.string() }) }, async (data, c) => {
    return { id: '123' }
  })

export default app
```

## Examples

### GET with Path Parameters

```ts
// app/routes/products/[id]/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('products')
  .endpoint('GET', '/', {
    input: z.object({ id: z.string().describe('Product ID') }),
    output: z.object({ id: z.string(), name: z.string(), price: z.number(), description: z.string() })
  }, async ({ id }, c) => {
    const product = c.span('db.select', { 'db.table': 'products', 'product.id': id }, () => db.products.findById(id))
    if (!product) return c.json({ error: 'Product not found' }, 404)
    return product
  })

export default app
```

### POST with Body

```ts
// app/routes/products/create/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('products')
  .endpoint('POST', '/', {
    input: z.object({ name: z.string().min(1), price: z.number().positive(), description: z.string().optional() }),
    output: z.object({ id: z.string(), name: z.string(), price: z.number(), createdAt: z.string() })
  }, async (data, c) => {
    const product = c.span('db.insert', { 'db.table': 'products' }, () => ({
      id: `prod_${Date.now()}`,
      ...data,
      createdAt: new Date().toISOString(),
    }))
    return product
  })

export default app
```

### Nested Dynamic Routes

```ts
// app/routes/users/[userId]/orders/[orderId]/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('orders')
  .endpoint('GET', '/', {
    input: z.object({ userId: z.string().describe('User ID'), orderId: z.string().describe('Order ID') }),
    output: z.object({
      id: z.string(),
      userId: z.string(),
      total: z.number(),
      items: z.array(z.object({ productId: z.string(), quantity: z.number() }))
    })
  }, async ({ userId, orderId }, c) => {
    const order = c.span('db.select', { 'db.table': 'orders', 'user.id': userId, 'order.id': orderId }, () => ({
      id: orderId,
      userId,
      total: 123.45,
      items: [{ productId: 'p1', quantity: 2 }]
    }))
    return order
  })

export default app
```

### Search/Query Params

```ts
// app/routes/products/search/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('products')
  .endpoint('GET', '/', {
    input: z.object({
      q: z.string().optional().describe('Search query'),
      category: z.string().optional().describe('Filter by category'),
      minPrice: z.number().optional().describe('Minimum price')
    }),
    output: z.object({
      products: z.array(z.object({ id: z.string(), name: z.string(), price: z.number() })),
      total: z.number()
    })
  }, async ({ q, category, minPrice }, c) => {
    const products = c.span('db.select', { 'db.table': 'products', 'search.query': q }, () => {
      const all = [
        { id: '1', name: 'Laptop', price: 999, category: 'computers' },
        { id: '2', name: 'Mouse', price: 29, category: 'accessories' },
      ]
      return all
        .filter(p => !q || p.name.toLowerCase().includes(q.toLowerCase()))
        .filter(p => !category || p.category === category)
        .filter(p => !minPrice || p.price >= minPrice)
    })
    return { products, total: products.length }
  })

export default app
```

## Context Helpers

### c.span()

Same as service builder - built into context:

```typescript
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('users')
  .endpoint('GET', '/', {
    input: z.object({}),
    output: z.object({
      user: z.object({ id: z.string() }).passthrough(),
      posts: z.array(z.object({ id: z.string() })).passthrough(),
    })
  }, async (_, c) => {
    const user = c.span('db.select', { 'db.table': 'users' }, () => {
      return { id: '123' }
    })
    const posts = c.span('db.select', { 'db.table': 'posts' }, () => {
      return [{ id: 'p1' }, { id: 'p2' }]
    })
    return { user, posts }
  })

export default app
```

### Standard Hono Context

All Hono methods work:

```typescript
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('examples')
  .endpoint('POST', '/', {
    input: z.object({ name: z.string().optional() }),
    output: z.object({ created: z.boolean() })
  }, async (data, c) => {
    // Get headers
    const token = c.req.header('Authorization')
    if (!token) {
      return c.json({ error: 'Unauthorized' }, 401)
    }
    // Set response headers
    c.header('X-Request-ID', 'req_' + Date.now())
    // Custom status codes
    return c.json({ created: true }, 201)
  })

export default app
```

## Middleware

### Service-Level Middleware

Apply to all endpoints within the service in a sub-app:

```ts
// app/routes/admin/users/index.ts
import { Vision } from '@getvision/server'
import { jwt } from 'hono/jwt'
import { z } from 'zod'

const app = new Vision()

app.service('admin-users')
  .use(jwt({ secret: process.env.JWT_SECRET! }))
  .endpoint('GET', '/', { input: z.object({}), output: z.object({ users: z.array(z.object({ id: z.string() })) }) }, async () => ({ users: [] }))

export default app
```

## Service Grouping

Routes are automatically grouped by path prefix in the Vision Dashboard:

```
app/routes/
├── products/index.ts               → Products service
├── products/[id]/index.ts          → Products service
├── users/[id]/orders/index.ts      → Users service
└── analytics/dashboard/index.ts    → Analytics service
```

**Dashboard shows:**
- **Products** (2 endpoints)
- **Users** (2 endpoints)
- **Analytics** (1 endpoint)

## Mixing Approaches

You can use both inline services in your root app AND file-based sub-apps:

```typescript
import { Vision } from '@getvision/server'

const app = new Vision({ service: { name: 'My API' } })

// Inline services (with pub/sub + cron)
app.service('notifications')
  .on('user/created', handler)
  .cron('0 9 * * *', handler)

// File-based routes (HTTP endpoints) are autodiscovered from app/routes/**/index.ts
// No manual loading required.

app.start(3000)
```

<Callout type="info">
  Use **service builder** for pub/sub + cron, **file-based routes** for HTTP endpoints!
</Callout>

## Best Practices

### 1. Keep Files Small

```typescript
// ✅ Good - One concern per file
// app/routes/products/index.ts - List & Create
// app/routes/products/[id]/index.ts - Get & Update & Delete
// app/routes/products/search/index.ts - Search

// ❌ Bad - Everything in one file
// app/routes/products/index.ts - All product operations
```

### 2. Use Meaningful Paths

```typescript
// ✅ Good - Clear intent
app/routes/products/search/index.ts
app/routes/users/[id]/orders/index.ts
app/routes/analytics/dashboard/index.ts

// ❌ Bad - Unclear
app/routes/search/index.ts
app/routes/data/index.ts
```

### 3. Add Schemas

```typescript
// ✅ Good - Full type safety + docs
.endpoint('GET', '/', {
  input: z.object({ id: z.string() }),
  output: z.object({ users: z.array(z.object({ id: z.string() })) }) },
  async () => ({ users: [] })
)

// ❌ Bad - No schemas
// (works but no validation or docs)
```

### 4. Group Related Routes

```
// ✅ Good - Logical grouping
app/routes/
├── products/
│   ├── index.ts
│   ├── [id]/index.ts
│   └── search/index.ts

// ❌ Bad - Flat structure
app/routes/
├── products-list.ts
├── products-get.ts
├── products-search.ts
```

## Complete Example

```ts
// app/routes/products/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('products')
  // GET /products - List all products
  .endpoint('GET', '/', {
    input: z.object({}),
    output: z.object({ products: z.array(z.object({ id: z.string(), name: z.string(), price: z.number(), inStock: z.boolean() })) })
  }, async (_, c) => {
    const allProducts = c.span('db.select', { 'db.table': 'products' }, () => [
      { id: '1', name: 'Laptop', price: 999, inStock: true },
    ])
    return { products: allProducts }
  })
  // POST /products - Create product
  .endpoint('POST', '/', {
    input: z.object({
      name: z.string().min(1).describe('Product name'),
      price: z.number().positive().describe('Product price'),
      description: z.string().optional().describe('Product description')
    }),
    output: z.object({ id: z.string(), name: z.string(), price: z.number(), createdAt: z.string() })
  }, async (data, c) => {
    const product = c.span('db.insert', { 'db.table': 'products' }, () => ({
      id: `prod_${Date.now()}`,
      ...data,
      createdAt: new Date().toISOString(),
    }))
    return product
  })

export default app
```

```ts
// app/routes/products/[id]/index.ts
import { Vision } from '@getvision/server'
import { z } from 'zod'

const app = new Vision()

app.service('products')
  // GET /products/:id - Get product by ID
  .endpoint('GET', '/', {
    input: z.object({ id: z.string().describe('Product ID') }),
    output: z.object({ id: z.string(), name: z.string(), price: z.number(), inStock: z.boolean(), description: z.string() })
  }, async ({ id }, c) => {
    const product = c.span('db.select', { 'db.table': 'products', 'product.id': id }, () => ({
      id,
      name: 'Laptop',
      price: 999,
      inStock: true,
      description: 'High-performance laptop'
    }))
    return product
  })

export default app
```

## Next Steps

- [Service Builder](/docs/server/service-builder) - Alternative approach
- [Features](/docs/features) - Explore all Vision features
